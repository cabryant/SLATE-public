package com.learning.slate;/*	Slate has been adapted from the TUIO Java Demo 	(part of the reacTIVision project http://reactivision.sourceforge.net)		Slate has been modified under the terms of the GNU General Public	License as published by the Free Software Foundation (version 2).*/import java.awt.Color;import java.awt.Font;import java.awt.FontMetrics;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.Point;import java.awt.RenderingHints;import java.awt.geom.AffineTransform;import java.awt.image.BufferedImage;import java.io.File;import java.util.ArrayList;import java.util.List;import java.util.Timer;import java.util.TimerTask;import java.util.TreeMap;import javax.imageio.ImageIO;import javax.swing.JComponent;import TUIO.TuioCursor;import TUIO.TuioListener;import TUIO.TuioObject;import TUIO.TuioTime;import com.learning.slate.Slate.Mode;import com.learning.slate.SlateComponent.PointF;import com.learning.slate.data.CalibrationSettings;import com.learning.slate.data.DataManager;import com.learning.slate.data.SlateSettings;import com.learning.slate.data.ToolkitSettings;import com.learning.slate.data.ToolkitSettings.Tangible;import com.learning.slate.toolkits.Resources.TextType;public class CalibrationComponent extends JComponent implements TuioListener{	private static final long serialVersionUID = 0L;		private Slate slate;	// Data Members	private SlateSettings slateSettings;	private ToolkitSettings toolkitSettings;	private CalibrationSettings calibrationSettings;		private static class CalibrationValue {		public PointF display;		public PointF camera;	}		private TuioObject currentTuioObject;	private BufferedImage currentBufferedImage;	private Point currentAnchorPoint;	private long lastDelay;	TreeMap<Integer,CalibrationValue> systemCalibrationMap;	private Integer systemCalibrationIndex;	private Integer toolkitCalibrationIndex;	List<Tangible> tangibles;		private static final long SYSTEM_CALIBRATION_DELAY = 5000;	private static final long TOOLKIT_CALIBRATION_DELAY_SETUP = 5000;	private static final long TOOLKIT_CALIBRATION_DELAY_READ = 1000;	private static final long TOOLKIT_CALIBRATION_DELAY_NOTIFY = 3000;		public CalibrationComponent(Slate slate, SlateSettings slateSettings) {		this.slate = slate;		this.slateSettings = slateSettings; 	}		public void reset() {		clearRepaintTimer();		clearSystemCalibrationTimer();		clearToolkitCalibrationTimer();	}		public void start() {		reset();		String toolkitName = slateSettings.getToolkit();		toolkitSettings = DataManager.getToolkitSettings(toolkitName);		calibrationSettings = DataManager.getCalibrationSettings(toolkitName);				startRepaintTimer(0);				prepareCalibrationMaps();		if (Mode.System_Calibration.equals(slate.getMode())) {			doSystemCalibration();		} else {			doToolkitCalibration();		}	}		private void prepareCalibrationMaps() {		currentTuioObject = null;		systemCalibrationIndex = null;		systemCalibrationMap = new TreeMap<Integer,CalibrationValue>();				CalibrationValue cv = new CalibrationValue();		cv.display = new PointF(.5f, .5f);		systemCalibrationMap.put(0, cv);				cv = new CalibrationValue();		cv.display = new PointF(.1f, .9f);		systemCalibrationMap.put(1, cv);				cv = new CalibrationValue();		cv.display = new PointF(.1f, .1f);		systemCalibrationMap.put(2, cv);				cv = new CalibrationValue();		cv.display = new PointF(.9f, .1f);		systemCalibrationMap.put(3, cv);				cv = new CalibrationValue();		cv.display = new PointF(.9f, .9f);		systemCalibrationMap.put(4, cv);				currentBufferedImage = null;		toolkitCalibrationIndex = null;		lastDelay = 0;		tangibles = new ArrayList<Tangible>();		tangibles.addAll(toolkitSettings.getTangibles().values());	}		private void doSystemCalibration() {		if (systemCalibrationIndex == null) {			// starting			systemCalibrationIndex = 0;		} else if (currentTuioObject != null) {			systemCalibrationMap.get(systemCalibrationIndex).camera = 				new PointF(currentTuioObject.getX(), currentTuioObject.getY());			systemCalibrationIndex++;		}		if (systemCalibrationIndex < systemCalibrationMap.size()) {			setTimeoutToCalibrate(SYSTEM_CALIBRATION_DELAY);		} else {			systemCalibrationIndex = null;			saveSystemCalibrationSettings();			reset();			slate.changeMode(slate.getMode());		}	}		private void saveSystemCalibrationSettings() {				// x-offset and y-offset		// 0		CalibrationValue point0 = systemCalibrationMap.get(0);		float offsetX = slateSettings.getOffsetX(point0.camera.getX(), point0.display.getX());		float offsetY = slateSettings.getOffsetY(point0.camera.getY(), point0.display.getY());				// distortionOffsetXHi (counter-intuitive, because camera is from the back)		// 3, 4		CalibrationValue point3 = systemCalibrationMap.get(3);		CalibrationValue point4 = systemCalibrationMap.get(4);		float distortionOffsetXLo = slateSettings.getDistortionOffsetX(				(point3.camera.getX() + point4.camera.getX()) / 2f, point3.display.getX());				// distortionOffsetXHi (counter-intuitive, because camera is from the back)		// 1, 2		CalibrationValue point1 = systemCalibrationMap.get(1);		CalibrationValue point2 = systemCalibrationMap.get(2);		float distortionOffsetXHi = slateSettings.getDistortionOffsetX(				(point1.camera.getX() + point2.camera.getX()) / 2f, point1.display.getX());				// distortionOffsetYHi		// 1, 4		float distortionOffsetYHi = slateSettings.getDistortionOffsetY(				(point1.camera.getY() + point4.camera.getY()) / 2f, point1.display.getY());				// distortionOffsetYLo		// 2, 3		float distortionOffsetYLo = slateSettings.getDistortionOffsetY(				(point2.camera.getY() + point3.camera.getY()) / 2f, point2.display.getY());				slateSettings.getCalibration().setOffsetX(offsetX);		slateSettings.getCalibration().setOffsetY(offsetY);		slateSettings.getCalibration().setDistortionOffsetXHi(distortionOffsetXHi);		slateSettings.getCalibration().setDistortionOffsetXLo(distortionOffsetXLo);		slateSettings.getCalibration().setDistortionOffsetYHi(distortionOffsetYHi);		slateSettings.getCalibration().setDistortionOffsetYLo(distortionOffsetYLo);				DataManager.saveSlateSettings(slateSettings);	}				private void doToolkitCalibration() {		if (toolkitCalibrationIndex == null) {			// starting			toolkitCalibrationIndex = 0;		} 		else if (lastDelay == TOOLKIT_CALIBRATION_DELAY_NOTIFY) {			toolkitCalibrationIndex++;		}		else if (currentTuioObject != null) {			saveToolkitCalibration(					tangibles.get(toolkitCalibrationIndex),					currentTuioObject,					currentBufferedImage);			//toolkitCalibrationIndex++;			long delay = TOOLKIT_CALIBRATION_DELAY_NOTIFY;			lastDelay = delay;			setTimeoutforToolkitCalibration(delay);			return;		}				if (toolkitCalibrationIndex < tangibles.size()) {			long delay = lastDelay;			if (lastDelay == 0) {				delay = TOOLKIT_CALIBRATION_DELAY_SETUP;			} else if (lastDelay == TOOLKIT_CALIBRATION_DELAY_SETUP) {				delay = TOOLKIT_CALIBRATION_DELAY_READ;			} else if (lastDelay == TOOLKIT_CALIBRATION_DELAY_READ) {				// If we get here, it wasn't read				delay = TOOLKIT_CALIBRATION_DELAY_SETUP;			} else if (lastDelay == TOOLKIT_CALIBRATION_DELAY_NOTIFY) {				delay = TOOLKIT_CALIBRATION_DELAY_SETUP;			}			lastDelay = delay;			setTimeoutforToolkitCalibration(delay);		} else {			toolkitCalibrationIndex = null;			reset();			slate.changeMode(slate.getMode());		}	}		private void saveToolkitCalibration(Tangible tangible, TuioObject tuioObject, BufferedImage image) {		CalibrationSettings.Tangible calibrationTangible = calibrationSettings.getTangibles().get(tangible.getName());		if (calibrationTangible == null) {			calibrationTangible = new CalibrationSettings.Tangible();		}		calibrationTangible.setName(tangible.getName());		calibrationTangible.setId(tuioObject.getSymbolID());				// TODO verify that these are correct				/*		<tangible name="Home"           id="7" base_angle="1.6034645" anchor_point_x="88"  anchor_point_y="69" />		<tangible name="InclinedPlane1" id="4" base_angle="1.548752"  anchor_point_x="104" anchor_point_y="80" />		<tangible name="InclinedPlane2" id="5" base_angle="1.6410083" anchor_point_x="173" anchor_point_y="80" />		<tangible name="Lever"          id="9" base_angle="0.0"       anchor_point_x="48"  anchor_point_y="142" />		<tangible name="Monster"        id="10" base_angle="1.7"      anchor_point_x="40"  anchor_point_y="40" />		<tangible name="WheelAndAxle"   id="6" base_angle="0.0"       anchor_point_x="66"  anchor_point_y="66" />		 */		// TODO - this should be doing some angular calibration, but not the preprocessing		// currently  done in getProjectionAngleFromCameraAngle		calibrationTangible.setBaseAngle(				/*slateSettings.getProjectionAngleFromCameraAngle(						tuioObject.getAngle(), 0, tangible.isRotates())*/ tuioObject.getAngle());		Point anchorPoint = getAnchorPoint(image);		int anchorPointX = Double.valueOf(				anchorPoint.getX() + ((.5f*slateSettings.getWindowHeight() - slateSettings.getProjectionYFromCameraY(tuioObject.getY())))).intValue();		int anchorPointY = Double.valueOf(				anchorPoint.getY() + ((slateSettings.getProjectionXFromCameraX(tuioObject.getX()) - .5f*slateSettings.getWindowWidth()))).intValue();		/*int anchorPointX = Double.valueOf(		anchorPoint.getX() - 		((.5f - tuioObject.getX()) * slateSettings.getWindowWidth())).intValue();int anchorPointY = Double.valueOf(		anchorPoint.getY() -		((.5f - tuioObject.getY()) * slateSettings.getWindowHeight())).intValue();*/				calibrationTangible.setAnchorPointX(anchorPointX);		calibrationTangible.setAnchorPointY(anchorPointY);				calibrationSettings.getTangibles().put(tangible.getName(), calibrationTangible);		DataManager.saveCalibrationSettings(calibrationSettings, toolkitSettings.getName());	}		private Point getAnchorPoint(BufferedImage image) {		return getAnchorPoint(image, 1f);	}		private Point getAnchorPoint(BufferedImage image, float scaleFactor) {		return new Point(				(int) ((((float) image.getWidth())  / 2f) * scaleFactor),				(int) ((((float) image.getHeight()) / 2f) * scaleFactor));					}		Timer systemCalibrationTimer = null;	private void setTimeoutToCalibrate(long delay) {		systemCalibrationTimer = new Timer();		systemCalibrationTimer.schedule(new SystemCalibrationTask(), delay);	}	class SystemCalibrationTask extends TimerTask {		public void run() {			doSystemCalibration();		}	}	private void clearSystemCalibrationTimer() {		if (systemCalibrationTimer != null) {			systemCalibrationTimer.cancel();			systemCalibrationTimer = null;		}	}		Timer toolkitCalibrationTimer = null;	private void setTimeoutforToolkitCalibration(long delay) {		toolkitCalibrationTimer = new Timer();		toolkitCalibrationTimer.schedule(new ToolkitCalibrationTask(), delay);	}	class ToolkitCalibrationTask extends TimerTask {		public void run() {			doToolkitCalibration();		}	}	private void clearToolkitCalibrationTimer() {		if (toolkitCalibrationTimer != null) {			toolkitCalibrationTimer.cancel();			toolkitCalibrationTimer = null;		}	}		Timer repaintTimer = null;	private void startRepaintTimer(long delay) {		repaintTimer = new Timer();		repaintTimer.scheduleAtFixedRate(new RefreshTimerTask(), delay, 60);	}	class RefreshTimerTask extends TimerTask {		public void run() {			repaint();		}	}	private void clearRepaintTimer() {		if (repaintTimer != null) {			repaintTimer.cancel();			repaintTimer = null;		}	}		public void addTuioCursor(TuioCursor tcur)    {}	public void updateTuioCursor(TuioCursor tcur) {}	public void removeTuioCursor(TuioCursor tcur) {}	synchronized public void addTuioObject(TuioObject tobj) {		currentTuioObject = tobj;	}	synchronized public void updateTuioObject(TuioObject tobj) {		currentTuioObject = tobj;	}	synchronized public void removeTuioObject(TuioObject tobj) {		currentTuioObject = null;	}	public void refresh(TuioTime frameTime) {		repaint();	}		@Override	public void paint(Graphics g) {		update(g);	}		@Override	public void update(Graphics g) {				Graphics2D g2 = (Graphics2D) g;		g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);		g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);				g2.setColor(Color.gray);		g2.fillRect(0,0,getWidth(),getHeight());		drawCommandCircle(g2, new PointF(.5f, .5f), 2.5d, Color.white);				// Show current Calibration Circle		if ((systemCalibrationIndex != null) && (systemCalibrationMap != null)) {			g2.setColor(Color.black);			g2.fillRect(0,0,getWidth(),getHeight());						CalibrationValue cv = systemCalibrationMap.get(systemCalibrationIndex);			if (cv != null) {				drawCommandCircle(g2, systemCalibrationMap.get(systemCalibrationIndex).display, 1d, Color.magenta);			}		}		else if ((toolkitCalibrationIndex != null) && (tangibles != null)) {			Tangible tangible = tangibles.get(toolkitCalibrationIndex);			if (tangible != null) {				if (lastDelay == TOOLKIT_CALIBRATION_DELAY_SETUP) {					drawCommandCircle(g2, new PointF(.5f, .5f), 2.5d, Color.cyan);					drawTangibleAtCenter(g2, tangible);					drawCalibrateInstructions(g2, tangible, .15f);				} else if (lastDelay == TOOLKIT_CALIBRATION_DELAY_READ) {					drawCommandCircle(g2, new PointF(.5f, .5f), 2.5d, Color.cyan);					drawCalibrateInstructions(g2, tangible, .15f);				} else if (lastDelay == TOOLKIT_CALIBRATION_DELAY_NOTIFY) {					drawCommandCircle(g2, new PointF(.5f, .5f), 2.5d, Color.yellow);					drawCalibrateSuccess(g2, tangible, .15f);				}			}		}		}		private void drawCalibrateInstructions(Graphics2D g2, Tangible tangible, float windowX) {		drawTextWithEmbeddedImage(				g2,				"Place tangible  ",				tangible,				"  over image to calibrate.",				"",				windowX);	}		private void drawCalibrateSuccess(Graphics2D g2, Tangible tangible, float windowX) {		drawTextWithEmbeddedImage(				g2,				"Tangible  ",				tangible,				"  calibrated!",				"_yellow",				windowX);	}		private void drawTextWithEmbeddedImage(Graphics2D g2, String text1, Tangible tangible, String text2, String fileSuffix, float windowX) {		try {			TextType textType = TextType.CalibrationInstructions;			FontMetrics metrics = g2.getFontMetrics(textType.getFont());			int fontHeight = metrics.getHeight();			//int fontAscent = metrics.getAscent();			int fontDescent = metrics.getDescent();			int width1 = metrics.stringWidth(text1);			int width2 = metrics.stringWidth(text2);						float tangibleScaleFactor = .5f;			String fileName = tangible.getImagePath(toolkitSettings.getName());			BufferedImage bufferedImage = ImageIO.read(new File(fileName));			int imageWidth = ((int) (bufferedImage.getWidth() * tangibleScaleFactor));						int totalWidth = width1 + imageWidth + width2;						int xOffset = (int) (windowX * slateSettings.getWindowWidth());			int yOffset1 = slateSettings.getWindowHeight() - (slateSettings.getWindowHeight() - totalWidth)/2;			int yOffset2 = yOffset1 - width1;			int yOffset3 = yOffset2 - imageWidth;			drawText(g2, text1, xOffset, yOffset1, textType);			drawTangible(g2,					tangible,					((float) (xOffset -  (((float)fontHeight)/2f) + fontDescent)) / slateSettings.getWindowWidth(),					((float) (yOffset2 - ((float)imageWidth)/2f))                 / slateSettings.getWindowHeight(),					tangibleScaleFactor,					fileSuffix);			drawText(g2, text2, xOffset, yOffset3, textType);		} catch (Throwable t) {			t.printStackTrace();		}	}		private void drawText(Graphics2D g2, String text, int translateX, int translateY, TextType textType) {		// text render		AffineTransform saveXform = g2.getTransform();		Font saveFont = g2.getFont();		RenderingHints saveHints = g2.getRenderingHints();		Color saveColor = g2.getColor();				g2.setColor(Color.white);		g2.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_GASP);		g2.setFont(textType.getFont());				AffineTransform transform = new AffineTransform();		transform.translate(translateX, translateY);		transform.rotate(-Math.PI/2f, 0, 0);				g2.transform(transform);		g2.drawString(text, 0, 0);		g2.setColor(saveColor);		g2.setRenderingHints(saveHints);		g2.setFont(saveFont);		g2.setTransform(saveXform);	}		private void drawTangibleAtCenter(Graphics2D g2, Tangible tangible)	{		drawTangible(g2, tangible, .5f, .5f, 1f, "");	}		private void drawTangible(Graphics2D g2, Tangible tangible, float windowX, float windowY, float scaleFactor, String fileSuffix)	{		String fileName = null;				try		{			fileName = tangible.getImagePath(toolkitSettings.getName());			String newFileName = fileName.replace(".", fileSuffix + ".");			if (new File(newFileName).exists()) {				fileName = newFileName;			}						AffineTransform saveXform = g2.getTransform();			currentBufferedImage = ImageIO.read(new File(fileName));					currentAnchorPoint = getAnchorPoint(currentBufferedImage, scaleFactor);						AffineTransform transform = new AffineTransform();			// Translate such that the anchor point is on the point, not the top left of the picture			transform.translate(windowX * slateSettings.getWindowWidth() - currentAnchorPoint.getX(), 					windowY * slateSettings.getWindowHeight() - currentAnchorPoint.getY());			// rotate the piece around the anchor point!			transform.rotate(-Math.PI/2d, currentAnchorPoint.getX(), currentAnchorPoint.getY());			g2.transform(transform);			g2.drawImage(currentBufferedImage.getScaledInstance((int) (currentBufferedImage.getWidth()*scaleFactor), 					(int) (currentBufferedImage.getHeight()*scaleFactor), 0), 0, 0, null);			g2.setTransform(saveXform);		}		catch (Exception e)		{			System.err.println("\n\n\nfile: " + fileName + "\n\n\n");			Logger.error(e.getMessage());			e.printStackTrace();		}	}		private void drawCommandCircle(Graphics2D g2, PointF point, double factor, Color borderColor) {			//System.out.println(point.getX() + "," + point.getY());			AffineTransform saveXform = g2.getTransform();		Color saveColor = g2.getColor();		g2.setColor(borderColor);		g2.fillOval(				(int) (point.getX()*getWidth() - factor*30d*8d/3d),				(int) (point.getY()*getHeight() - factor*30d*8d/3d),				(int) (factor*30d*16d/3d),				(int) (factor*30d*16d/3d));		g2.setColor(Color.white);		g2.fillOval(				(int) (point.getX()*getWidth() - factor*30d*32d/15d),				(int) (point.getY()*getHeight() - factor*30d*32d/15d),				(int) (factor*30d*64d/15d),				(int) (factor*30d*64d/15d));		g2.setColor(saveColor);		g2.setTransform(saveXform);		}		// OPTION 2	/*	private void prepareCalibrationMaps() {		systemCalibrationMap = new TreeMap<Integer,CalibrationValue>();		systemCalibrationIndex = null;		currentTuioObject = null;				CalibrationValue cv = new CalibrationValue();		cv.display = new PointF(.5f, .5f);		systemCalibrationMap.put(0, cv);				cv = new CalibrationValue();		cv.display = new PointF(.1f, .5f);		systemCalibrationMap.put(1, cv);				cv = new CalibrationValue();		cv.display = new PointF(.5f, .1f);		systemCalibrationMap.put(2, cv);				cv = new CalibrationValue();		cv.display = new PointF(.9f, .5f);		systemCalibrationMap.put(3, cv);				cv = new CalibrationValue();		cv.display = new PointF(.5f, .9f);		systemCalibrationMap.put(4, cv);	}*/		/* OPTION 2	private void saveSystemCalibrationSettings() {				// x-offset and y-offset		// 0		CalibrationValue point0 = systemCalibrationMap.get(0);		float offsetX = slateSettings.getOffsetX(point0.camera.getX(), point0.display.getX());		float offsetY = slateSettings.getOffsetY(point0.camera.getY(), point0.display.getY());				// distortionOffsetXHi (counter-intuitive, because camera is from the back)		// 1		CalibrationValue point1 = systemCalibrationMap.get(1);		float distortionOffsetXHi = slateSettings.getDistortionOffsetX(point1.camera.getX(), point1.display.getX());				// distortionOffsetXLo (counter-intuitive, because camera is from the back)		// 3		CalibrationValue point3 = systemCalibrationMap.get(3);		float distortionOffsetXLo = slateSettings.getDistortionOffsetX(point3.camera.getX(), point3.display.getX());				// distortionOffsetYHi (counter-intuitive, because camera is from the back)		// 2		CalibrationValue point2 = systemCalibrationMap.get(2);		float distortionOffsetYHi = slateSettings.getDistortionOffsetY(point2.camera.getY(), point2.display.getY());				// distortionOffsetYLo (counter-intuitive, because camera is from the back)		// 4		CalibrationValue point4 = systemCalibrationMap.get(4);		float distortionOffsetYLo = slateSettings.getDistortionOffsetY(point4.camera.getY(), point4.display.getY());				slateSettings.getCalibration().setOffsetX(offsetX);		slateSettings.getCalibration().setOffsetY(offsetY);		slateSettings.getCalibration().setDistortionOffsetXHi(distortionOffsetXHi);		slateSettings.getCalibration().setDistortionOffsetXLo(distortionOffsetXLo);		slateSettings.getCalibration().setDistortionOffsetYHi(distortionOffsetYHi);		slateSettings.getCalibration().setDistortionOffsetYLo(distortionOffsetYLo);				DataManager.saveSlateSettings(slateSettings);	}*/}