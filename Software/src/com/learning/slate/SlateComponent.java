package com.learning.slate;/*	Slate has been adapted from the TUIO Java Demo 	(part of the reacTIVision project http://reactivision.sourceforge.net)		Slate has been modified under the terms of the GNU General Public	License as published by the Free Software Foundation (version 2).*/import java.awt.Graphics;import java.awt.Point;import java.awt.image.BufferedImage;import java.io.File;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.swing.JComponent;import TUIO.TuioCursor;import TUIO.TuioListener;import TUIO.TuioObject;import TUIO.TuioTime;import com.learning.slate.data.CalibrationSettings;import com.learning.slate.data.DataManager;import com.learning.slate.data.Library;import com.learning.slate.data.Library.Challenge;import com.learning.slate.data.Library.Piece;import com.learning.slate.data.SlateSettings;import com.learning.slate.data.ToolkitSettings;import com.learning.slate.data.ToolkitSettings.Action;import com.learning.slate.data.ToolkitSettings.Tutorial;import com.learning.slate.toolkits.ISlateObject;import com.learning.slate.toolkits.ISlideShow;import com.learning.slate.toolkits.IStateEnum;import com.learning.slate.toolkits.IToolkit;import com.learning.slate.toolkits.Resources;public class SlateComponent extends JComponent implements TuioListener{	private static final long serialVersionUID = 0L;		// Data Members	private SlateSettings slateSettings;	private ToolkitSettings toolkitSettings;	private CalibrationSettings calibrationSettings;	private Library library;		public SlateComponent(SlateSettings slateSettings) {		load(slateSettings);				// FIXME - remove this after user testing - we don't always want to log		//toggleEventLogger();	}		public Library getLibrary() {		return library;	}		public ToolkitSettings getToolkitSettings() {		return toolkitSettings;	}		public SlateSettings getSlateSettings() {		return slateSettings;	}		private IToolkit getSlateToolkit() throws ClassNotFoundException, InstantiationException, IllegalAccessException {		return toolkitSettings.getToolkit(this);	}		public void load(SlateSettings slateSettings) {		this.slateSettings = slateSettings;		reset();	}		public void reset() {		// TODO? objectMap = new HashMap<Integer,Map<Long,SlateObject>>();		String toolkitName = slateSettings.getToolkit();		toolkitSettings = DataManager.getToolkitSettings(toolkitName);		calibrationSettings = DataManager.getCalibrationSettings(toolkitName);		library = DataManager.getLibrary(toolkitName);				try {			getSlateToolkit().reset();		} catch (Throwable t) {			t.printStackTrace();		}	}		public void toggleEventLogger() {		try {			getSlateToolkit().toggleEventLogger();		} catch (Throwable t) {			t.printStackTrace();		}	}		public void updateGraphics(Graphics g) {		try {			getSlateToolkit().updateGraphics(g);		} catch (Throwable t) {			t.printStackTrace();		}	}		public String getLogDirectoryName() {		return DataManager.getLogDirectoryName(toolkitSettings.getName());	}		// TODO should this be here?  Should Tutorial Zone be in Resources?	public boolean isInTutorialZone(SlateObject slateObject) {		return Resources.isInTutorialZone(getProjectionX(slateObject), getProjectionY(slateObject));	}		public Action getAction(SlateObject slateObject) {		int fiducialId = slateObject.getSymbolID();		String name = calibrationSettings.getActionNameByFiducialId(fiducialId);		if (name != null) {			Action action = toolkitSettings.getActions().get(name);			if (action != null) {				return action;			}		}		try {			IToolkit toolkit = getSlateToolkit();			if (toolkit != null) {				name = CalibrationSettings.getActionNameByFiducialId(fiducialId, 						toolkit.getDefaultCalibrationActions());				if (name != null) {					Action action = toolkit.getDefaultToolkitActions().get(name);					if (action != null) {						return action;					}				}			}		} catch (Throwable t) {			t.printStackTrace();		}		reportUnrecognizedFiducialId(fiducialId);		return null;	}	public Action getAction(String resourceName) {		ToolkitSettings.Action action = toolkitSettings.getActions().get(resourceName);		if (action != null) {			return action;		}		try {			IToolkit toolkit = getSlateToolkit();			if (toolkit != null) {				action = toolkit.getDefaultToolkitActions().get(resourceName);				if (action != null) {					return action;				}			}		} catch (Throwable t) {			t.printStackTrace();		}		reportUnrecognizedResourceName(resourceName);		return null;	}		public Tutorial getTutorial(SlateObject slateObject) {		int fiducialId = slateObject.getSymbolID();		String tangible = calibrationSettings.getTangibleNameByFiducialId(fiducialId);		if (tangible != null) {			return toolkitSettings.getTutorials().get(toolkitSettings.getTangibles().get(tangible).getTutorial());		}		String action = calibrationSettings.getActionNameByFiducialId(fiducialId);		if (action != null) {			return toolkitSettings.getTutorials().get(toolkitSettings.getActions().get(action).getTutorial());		}		try {			IToolkit toolkit = getSlateToolkit();			if (toolkit != null) {				action = CalibrationSettings.getActionNameByFiducialId(fiducialId, 						toolkit.getDefaultCalibrationActions());				if (action != null) {					return toolkit.getDefaultToolkitTutorials().get(toolkit.getDefaultToolkitActions().get(action).getTutorial());				}			}		} catch (Throwable t) {			t.printStackTrace();		}		reportUnrecognizedFiducialId(fiducialId);		return null;	}		public String getCurrentStateImage(IStateEnum state) {		String fileName = getCurrentStateImage(state.getSlideShow(), toolkitSettings.getName(), state.getFileName());		if ((new File(fileName)).exists()) {			return fileName;		}		return getCurrentStateImage(state.getSlideShow(), SlateSettings.DEFAULT_TOOLKIT, state.getFileName());	}		private String getCurrentStateImage(ISlideShow slideShow, String toolkitName, String fileName) {		if ((slideShow != null) && slideShow.isRunning()) {			return DataManager.getSlideShowFilePath(toolkitName, slideShow.getCurrentImageFileName());		} else {			return DataManager.getStatesPath(toolkitName, fileName);		}	}		public boolean isTangible(int fiducialId) {		return (calibrationSettings.getTangibleByFiducialId(fiducialId) != null);	}	public boolean isTangible(String resourceName) {		return toolkitSettings.getTangibles().containsKey(resourceName);	}		public Piece getPiece(ISlateObject slateObject) {				int fiducialId = slateObject.getSymbolID();				// defaults for actions		float baseAngle = 0;		boolean rotates = true;				// See if this is an action.  If so, use the default values above		String name = calibrationSettings.getActionNameByFiducialId(fiducialId);		if (name == null) {			try {				IToolkit toolkit = getSlateToolkit();				if (toolkit != null) {					name = CalibrationSettings.getActionNameByFiducialId(fiducialId, toolkit.getDefaultCalibrationActions());				}			} catch (Throwable t) {				t.printStackTrace();			}		}		if (name == null) {			// This is a Tangible			CalibrationSettings.Tangible tangible = calibrationSettings.getTangibleByFiducialId(fiducialId);			if (tangible == null) {				reportUnrecognizedFiducialId(fiducialId);			}			name = tangible.getName();			baseAngle = tangible.getBaseAngle();			rotates = toolkitSettings.getTangibles().get(name).isRotates();		}				float x = getProjectionX(slateObject);		float y = getProjectionY(slateObject);		//System.out.println(name + " " + slateObject.getAngle() + " " + baseAngle + " " + rotates);		float angle = getProjectionAngle(slateObject, baseAngle, rotates);		return new Piece(name, angle, x, y);	}		public static class PointF {		private float x;		private float y;				public PointF(float x, float y) {			this.x = x;			this.y = y;		}		public float getX() {			return x;		}		public float getY() {			return y;		}	}		public PointF getProjectionPoint(ISlateObject slateObject) {		return new PointF(getProjectionX(slateObject), getProjectionY(slateObject));	}		public PointF getProjectionPoint(SlateObject slateObject, float xOffset, float yStart) {		float x = getProjectionX(slateObject) + xOffset;		float y = slateSettings.getProjectionYFromCameraY(yStart);		return new PointF(x, y);	}		private float getProjectionX(ISlateObject slateObject) {		return slateSettings.getProjectionXFromCameraX(slateObject.getX());	}	private float getProjectionY(ISlateObject slateObject) {		return slateSettings.getProjectionYFromCameraY(slateObject.getY());	}	private float getProjectionAngle(ISlateObject slateObject, float baseAngle, boolean rotates) {		return slateSettings.getProjectionAngleFromCameraAngle(slateObject.getAngle(), baseAngle, rotates);	}		private void reportUnrecognizedFiducialId(int fiducialId) throws IllegalArgumentException {		throw new IllegalArgumentException("Unrecognized Fiducial ID: " + fiducialId);	}		private void reportUnrecognizedResourceName(String name) throws IllegalArgumentException {		throw new IllegalArgumentException("Unrecognized Resource Name: " + name);	}	public Point getAnchorPoint(String resourceName) {		CalibrationSettings.Action action = calibrationSettings.getActions().get(resourceName);		if (action != null) {			return new Point(action.getAnchorPointX(), action.getAnchorPointY()); 		}		CalibrationSettings.Tangible tangible = calibrationSettings.getTangibles().get(resourceName);		if (tangible != null) {			return new Point(tangible.getAnchorPointX(), tangible.getAnchorPointY());		}		try {			IToolkit toolkit = getSlateToolkit();			if (toolkit != null) {				action = toolkit.getDefaultCalibrationActions().get(resourceName);				if (action != null) {					return new Point(action.getAnchorPointX(), action.getAnchorPointY());				}			}		} catch (Throwable t) {			t.printStackTrace();		}		reportUnrecognizedResourceName(resourceName);		return null;	}		public Point getInstructionsAnchorPoint(String resourceName) {		CalibrationSettings.Action action = calibrationSettings.getActions().get(resourceName);		if (action != null) {			return new Point(action.getInstructionsAnchorPointX(), action.getInstructionsAnchorPointY()); 		}		try {			IToolkit toolkit = getSlateToolkit();			if (toolkit != null) {				action = toolkit.getDefaultCalibrationActions().get(resourceName);				if (action != null) {					return new Point(action.getInstructionsAnchorPointX(), action.getInstructionsAnchorPointY());				}			}		} catch (Throwable t) {			t.printStackTrace();		}		reportUnrecognizedResourceName(resourceName);		return null;	}		public String getImageFileName(String resourceName) {		ToolkitSettings.Action action = toolkitSettings.getActions().get(resourceName);		if (action != null) {			return action.getImagePath(toolkitSettings.getName());		}			ToolkitSettings.Tangible tangible = toolkitSettings.getTangibles().get(resourceName);		if (tangible != null) {			return tangible.getImagePath(toolkitSettings.getName());		}				try {			IToolkit toolkit = getSlateToolkit();			if (toolkit != null) {				ToolkitSettings.Action defaultAction = toolkit.getDefaultToolkitActions().get(resourceName);				if (defaultAction != null) {					return defaultAction.getImagePath(SlateSettings.DEFAULT_TOOLKIT);				}			}		} catch (Throwable t) {			t.printStackTrace();		}		reportUnrecognizedResourceName(resourceName);		return null;	}		public String getInstructionsImageFileName(String resourceName) {		ToolkitSettings.Action action = toolkitSettings.getActions().get(resourceName);		if (action != null) {			return action.getInstructionsFilePath(toolkitSettings.getName());		}			try {			IToolkit toolkit = getSlateToolkit();			if (toolkit != null) {				ToolkitSettings.Action defaultAction = toolkit.getDefaultToolkitActions().get(resourceName);				if (defaultAction != null) {					return defaultAction.getInstructionsFilePath(SlateSettings.DEFAULT_TOOLKIT);				}			}		} catch (Throwable t) {			t.printStackTrace();		}		reportUnrecognizedResourceName(resourceName);		return null;	}		public Point getAnchorPoint(BufferedImage image) {		return new Point(				(int) (((float) image.getWidth())  / 2f),				(int) (((float) image.getHeight()) / 2f));					}		public Point getAnchorPoint(SlateObject slateObject) {		int fiducialId = slateObject.getSymbolID();				CalibrationSettings.Action action = calibrationSettings.getActionByFiducialId(fiducialId);		if (action != null) {			return new Point(action.getAnchorPointX(), action.getAnchorPointY()); 		} else {			CalibrationSettings.Tangible tangible = calibrationSettings.getTangibleByFiducialId(fiducialId);			if (tangible != null) {				return new Point(tangible.getAnchorPointX(), tangible.getAnchorPointY());			}		}		try {			IToolkit toolkit = getSlateToolkit();			if (toolkit != null) {				CalibrationSettings.Action defaultAction = 					CalibrationSettings.getActionByFiducialId(fiducialId, toolkit.getDefaultCalibrationActions());				if (defaultAction != null) {					return new Point(defaultAction.getAnchorPointX(), defaultAction.getAnchorPointY());				}			}		} catch (Throwable t) {			t.printStackTrace();		}		reportUnrecognizedFiducialId(fiducialId);		return null;	}		public void removeChallengePieces(List<Piece> sortedSolutionPieces, Challenge challenge) {		// filter the challenge pieces out of the solution		for (Piece challengePiece : challenge.getPieces()) {			for (Piece solutionPiece : sortedSolutionPieces) {					if (areOverlappingPieces(solutionPiece, challengePiece)) {					sortedSolutionPieces.remove(solutionPiece);					break;				}			}		}	}		public boolean isInFilterList(SlateObject slateObject, List<SlateObject> filterList) {		for (SlateObject filterSlateObject : filterList)		{			if (areOverlappingSlateObjects(slateObject, filterSlateObject)) {				return true;			}		}		return false;	}		private boolean areOverlappingSlateObjects(SlateObject slateObject1, SlateObject slateObject2) {		float overlap = slateSettings.getTangibleBaseWidthPixels();				return ((slateObject1.getSymbolID() == slateObject2.getSymbolID()) &&				(Math.abs(slateSettings.getProjectionXFromCameraX(slateObject1.getX()) - 						slateSettings.getProjectionXFromCameraX(slateObject2.getX())) < overlap) &&			(Math.abs(slateSettings.getProjectionYFromCameraY(slateObject1.getY()) - 					slateSettings.getProjectionYFromCameraY(slateObject2.getY())) < overlap));	}		private boolean areOverlappingPieces(Piece piece1, Piece piece2) {		float overlap = slateSettings.getTangibleBaseWidthPixels();		return ((piece1.getName().equals(piece2.getName()) &&				(Math.abs(piece1.getX() - piece2.getX()) < overlap) &&				(Math.abs(piece1.getY() - piece2.getY()) < overlap)));	}		public String getResourceName(ISlateObject slateObject) {		int fiducialId = slateObject.getSymbolID();		String name = calibrationSettings.getActionNameByFiducialId(fiducialId);		if (name != null) {			return name;		}		name = calibrationSettings.getTangibleNameByFiducialId(fiducialId);		if (name != null) {			return name;		}		try {			IToolkit toolkit = getSlateToolkit();			if (toolkit != null) {				name = CalibrationSettings.getActionNameByFiducialId(fiducialId,						toolkit.getDefaultCalibrationActions());				if (name != null) {					return name;				}			}		} catch (Throwable t) {			t.printStackTrace();		}		reportUnrecognizedFiducialId(fiducialId);		return null;	}		public Integer getSymbolID(String resourceName) {		CalibrationSettings.Action action = calibrationSettings.getActions().get(resourceName);		if (action != null) {			return action.getId();		}		CalibrationSettings.Tangible tangible = calibrationSettings.getTangibles().get(resourceName);		if (tangible != null) {			return tangible.getId();		}		try {			IToolkit toolkit = getSlateToolkit();			if (toolkit != null) {				action = toolkit.getDefaultCalibrationActions().get(resourceName);				if (action != null) {					return action.getId();				}			}		} catch (Throwable t) {			t.printStackTrace();		}				reportUnrecognizedResourceName(resourceName);		return null;	}		public void processEvent(SlateObject slateObject, TuioAction tuioAction, float deltaAngle, float deltaX, float deltaY)		throws ClassNotFoundException, InstantiationException, IllegalAccessException {				Action action = null;		try {			action = getAction(slateObject);		} catch (Throwable e) {			// TODO Auto-generated catch block			//e.printStackTrace();		}				getSlateToolkit().processEvent(				slateObject,				action,				tuioAction,				deltaAngle,				deltaX,				deltaY,				isInTutorialZone(slateObject));	}				/*============= FORMERLY SLATE COMPONENT ============ */			public enum TuioAction	{		Add,		Update,		Remove;				public static TuioAction getTuioActionByName(String name)		{			for (TuioAction action : TuioAction.values())			{				if (action.name().equals(name))				{					return action;				}			}						return null;		}	}		// Symbol ID : [Session Id : Object]	private Map<Integer,Map<Long,SlateObject>> objectMap = new HashMap<Integer,Map<Long,SlateObject>>();		public Map<Integer,Map<Long,SlateObject>> getObjectMap() {		return objectMap;	}		/*                      */	/* TuioListener methods */	/*                      */		// We don't need the cursor methods, but we must implement them	public void addTuioCursor(TuioCursor tcur) {		//log("[!] add cur " + tcur.getCursorID() + " (" + tcur.getSessionID() + ") " + tcur.getX() + " " + tcur.getY());	}	public void updateTuioCursor(TuioCursor tcur) { 		//log("[!] set cur " + tcur.getCursorID() + " (" + tcur.getSessionID() + ") " + tcur.getX() + " " + tcur.getY() + " " + tcur.getMotionSpeed() + " " + tcur.getMotionAccel());	}	public void removeTuioCursor(TuioCursor tcur) {		//log("[!] del cur " + tcur.getCursorID() + " (" + tcur.getSessionID()+")");	}		// Object / Command Tracking		synchronized public void addTuioObject(TuioObject tobj)	{		SlateObject slateObject = new SlateObject(tobj);		int id = slateObject.getSymbolID();				Map<Long,SlateObject> map = objectMap.get(id);		if (map == null)		{			map = new HashMap<Long,SlateObject>();			objectMap.put(id, map);		}		map.put(tobj.getSessionID(), slateObject);			/*		log("add obj " 				+ id + " "				+ "(" + tobj.getSessionID() + ") " 				+ tobj.getX() + " " 				+ tobj.getY() + " " 				+ tobj.getAngle());		log("add obj "				+ id + " "				+ "(" + tobj.getSessionID() + ") "				+ SlateComponent.getProjectionXFromCameraX(tobj.getX(), SlateComponent.X_CALIBRATION_OFFSET) + " "				+ SlateComponent.getProjectionYFromCameraY(tobj.getY(), SlateComponent.Y_CALIBRATION_OFFSET) + " "				+ tobj.getAngle());		*/				processEvent(tobj, TuioAction.Add);	}		synchronized public void updateTuioObject(TuioObject tobj)	{		Map<Long,SlateObject> map = objectMap.get(tobj.getSymbolID());		if (map == null)		{			Logger.error("Failure to retrieve object for update [" + tobj.getSymbolID() + "] . . . Adding.");			addTuioObject(tobj);			return;		}				SlateObject mo = map.get(tobj.getSessionID());		if (mo == null)		{			Logger.error("Failure to retrieve object for update [" + tobj.getSymbolID() + ", " + tobj.getSessionID() + "] . . . Adding.");			addTuioObject(tobj);			return;		}				// Get the deltas		float deltaAngle = tobj.getAngle() - (mo.getAngle() == 0 ? tobj.getAngle() : mo.getAngle());		float deltaX = tobj.getX() - mo.getX();		float deltaY = tobj.getY() - mo.getY();				mo.update(tobj);				/*		if (tobj.getSymbolID() == 11) logger.log("set obj "				+ tobj.getSymbolID() + " "				+ "("+ tobj.getSessionID() + ") "				+ tobj.getX() + " "				+ tobj.getY() + " "				+ tobj.getAngle() + " "				+ tobj.getMotionSpeed() + " "				+ tobj.getRotationSpeed() + " "				+ tobj.getMotionAccel() + " "				+ tobj.getRotationAccel());		*/		processEvent(tobj, TuioAction.Update, deltaAngle, deltaX, deltaY);	}		synchronized public void removeTuioObject(TuioObject tobj)	{		Map<Long,SlateObject> map = objectMap.get(tobj.getSymbolID());		if (map == null)		{			Logger.error("Attempted to remove untracked object [" + tobj.getSymbolID() + "]");			return;		}		if (!map.containsKey(tobj.getSessionID()))		{			Logger.error("Attempted to remove untracked object [" + tobj.getSymbolID() + ", " + tobj.getSessionID() + "]");			return;		}		map.remove(tobj.getSessionID());				// clean up the object map also		if (map.size() == 0)		{			objectMap.remove(tobj.getSymbolID());		}				/*log("del obj "				+ tobj.getSymbolID() + " "				+ "(" + tobj.getSessionID() + ")");*/				processEvent(tobj, TuioAction.Remove);	}	public void refresh(TuioTime frameTime)	{		repaint();	}		/* End: TiuoListener methods */				/* STATE MACHINE */	private void processEvent(TuioObject tobj, TuioAction action)	{		processEvent(tobj, action, 0f, 0f, 0f);	}			private void processEvent(TuioObject tobj, TuioAction tuioAction, float deltaAngle, float deltaX, float deltaY)	{		SlateObject slateObject = new SlateObject(tobj);				try {			processEvent(slateObject, tuioAction, deltaAngle, deltaX, deltaY);		} catch (Throwable t) {			t.printStackTrace();		}	}			/*                */	/* Rendering code */	/*                */	@Override	public void paint(Graphics g)	{		update(g);	}		@Override	public void update(Graphics g)	{		updateGraphics(g);	}}